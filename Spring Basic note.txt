[비즈니스 요구사항과 설계]

<회원>
회원을 가입하고 조회할 수 있다.
회원은 일반과 VIP 두 가지 등급이 있다.
회원 데이터는 자체 DB를 구축할 수 있고, 외부 시스템과 연동할 수 있다. (미확정)

<주문과 할인 정책>
회원은 상품을 주문할 수 있다.
회원 등급에 따라 할인 정책을 적용할 수 있다.
할인 정책은 모든 VIP는 1000원을 할인해주는 고정 금액 할인을 적용해달라. (나중에 변경 될 수 있다.)
할인 정책은 변경 가능성이 높다. 회사의 기본 할인 정책을 아직 정하지 못했고, 오픈 직전까지 고민을 미루고 싶다. 최악의 경우 할인을 적용하지 않을 수 도 있다. (미확정)

* Ctrl + shift + t : create test
* @DisplayName("") : test시 출력되는 메시지
* static import 찾아보기(자바 기본 문법)

<스프링으로 전환하기>
@Configuration : 애플리케이션의 설정(구성)정보
@Bean
 - 각 메서드에 써주면 스프링컨테이너에 등록이 됨
 - 빈 이름 직접 부여 가능 ex. @Bean(name="memberSerivce2")
 - 빈 이름은 항상 다른 이름을 부여해야 한다.(실무에서는 무조건 단순! 명확!)
ApplicationContext : 스프링은 모든게 ApplicationContext로 시작됨, 이게 스프링컨테이너
- getBean으로 메서드를 불러올 때 기본적으로 메서드명과 타입을 써줌
  (ex. MemberService memberService = applicationContext.getBean("memberService", MemberService.class);)

4. 스프링 컨테이너와 스프링빈
` iter -> enter(tab) : for문 자동생성
` soutv : 변수명 출력 
` ctrl + d : 복붙 바로해줌
` 빈 출력
  - ac.getBeanDefinitionNames() : 스프링에 등록된 모든 빈 이름을 조회한다.
  - ac.getBean() : 빈 이름으로 빈 객체(인스턴스)를 조회
` getRole()
  - ROLE_APPLICATION : 일반적으로 사용자가 정의한 빈
  - ROLE_INFRASTRUCTURE : 스프링이 내부에서 사용하는 빈

[스프링 빈 조회 - 동일 타입 둘 이상]
` static의 장점? 클래스 안에 클래스를 썼다는 건, 그 안에서만 쓰겠다는 것
`ac.getBeansOfType() 을 사용하면 해당 타입의 모든 빈을 조회할 수 있다
  - Map으로 나옴, key/value값으로 
` 스프링빈 예외
  - NoSuchBeanDefinitionException: 조회 대상 스프링 빈이 없으면 예외 발생
  - NoUniqueBeanDefinitionException : 조회 대상 중복
* ctrl + shift + enter : 코드 컴플레이션으로 넘어감 

[스프링 빈 조회 - 상속 관계]★
` 부모 타입으로 조회하면, 자식 타입도 함께 조회한다
` 모든 자바 객체의 최고 부모인 Object 타입으로 조회하면, 모든 스프링 빈을 조회

[스프링 빈 설정 메타 정보 - BeanDefinition] - 개발하는데 지장없는 개념
` 스프링 컨테이너는 이 메타정보를 기반으로 스프링 빈을 생성한다.
` 스프링이 다양한 형태의 설정 정보를 BeanDefinition으로 추상화해서 사용하는 것 정도만 이해하면 된다.
` 스프링 빈 생성 두가지 방법
  - 직접 스프링 빈 등록
  - factoryBean을 통해서 등록

5. 싱글톤 컨테이너
[스프링 없는 순수 DI 컨테이너]
` 호출할 때 마다 객체 생성 -> 메모리 낭비 심함
` 해결 방안: 해당 객체가 딱 1개만 생성되고, 공유하도록 설계 => 싱글톤 패턴
` 싱글톤 패턴, 많은 문제점 존재
  - 싱글톤 패턴을 구현하는 코드 자체가 많이 들어간다.
  - 의존관계상 클라이언트가 구체 클래스에 의존한다 -> DIP를 위반한다.
  - 클라이언트가 구체 클래스에 의존해서 OCP 원칙을 위반할 가능성이 높다.
  - 테스트하기 어렵다.
  - 내부 속성을 변경하거나 초기화하기 어렵다.
  - private 생성자로 자식 클래스를 만들기 어렵다.
  - 결론적으로 유연성이 떨어진다.
  - 안티패턴으로 불리기도 한다

[싱글톤 컨테이너]
` 스프링 컨테이너는 싱글턴 패턴을 적용하지 않아도, 객체 인스턴스를 싱글톤으로 관리
` 싱글턴 패턴의 모든 단점을 해결하면서 객체를 싱글톤으로 유지할 수 있다.

[싱글톤 방식의 주의점]
` 스프링 빈은 항상 무상태(stateless)로 설계
 - 특정 클라이언트에 의존적인 필드가 있으면 안된다.
 - 특정 클라이언트가 값을 변경할 수 있는 필드가 있으면 안된다!
 - 가급적 읽기만 가능해야 한다.
 - 필드 대신에 자바에서 공유되지 않는, 지역변수, 파라미터, ThreadLocal 등을 사용해야 한다.

[@Configuration과 싱글톤]
` @Bean만 사용해도 스프링 빈으로 등록되지만, 싱글톤을 보장하지 않는다.
` 스프링 설정 정보는 항상 @Configuration 을 사용하자★


6. 컴포넌트 스캔
[컴포넌트 스캔과 의존관계 자동 주입]
` @Bean으로 직접 스프링빈으로 등록할 필요없이, 컴포넌트 스캔!! 기능을 제공
` 의존관계도 자동으로 주입하는 @Autowired 기능 제공
` @ComponentScan을 설정 정보에 붙여주면 된다.
` @ComponentScan 은 @Component 가 붙은 모든 클래스를 스프링 빈으로 등록한다.
` 이때 스프링 빈의 기본 이름은 클래스명을 사용하되 맨 앞글자만 소문자를 사용한다.
  - ex) MemberServiceImpl 클래스 memberServiceImpl
  - 직접 지정: @Component("memberService2") 이런식으로 이름을 부여하면 된다.
` 생성자에 @Autowired 를 지정하면, 스프링 컨테이너가 자동으로 해당 스프링 빈을 찾아서 주입한다.

[탐색 위치와 기본 스캔 대상]
` basePackages : 탐색할 패키지의 시작 위치를 지정, 이 패키지 포함해서 하위 패키지를 모두 탐색
  - basePackages = {"hello.core", "hello.service"} 이렇게 여러 시작 위치를 지정할 수도 있다.
` basePackageClasses : 지정한 클래스의 패키지를 탐색 시작 위치로 지정
` 지정하지 않으면 @ComponentScan이 붙은 정보 클래스의 패키지가 시작 위치가 됨
` 권장 방법: 설정 정보 클래스의 위치를 프로젝트 최상단에 두는 것. 최근 스프링 부트도 이 방법을 기본으로 제공

[컴포넌트 스캔 기본 대상]
` @Component : 컴포넌트 스캔에서 사용
` @Controlller : 스프링 MVC 컨트롤러에서 사용
` @Service : 스프링 비즈니스 로직에서 사용
` @Repository : 스프링 데이터 접근 계층에서 사용
` @Configuration : 스프링 설정 정보에서 사용

[필터]
` includeFilters : 컴포넌트 스캔 대상을 추가로 지정한다.
` excludeFilters : 컴포넌트 스캔에서 제외할 대상을 지정한다.
` FilterType 옵션 5가지 

7. 의존관계 자동 주입
1) ANNOTATION: 기본값, 애노테이션을 인식해서 동작한다.
  ex) org.example.SomeAnnotation
2) ASSIGNABLE_TYPE: 지정한 타입과 자식 타입을 인식해서 동작한다.
  ex) org.example.SomeClass
3) ASPECTJ: AspectJ 패턴 사용
  ex) org.example..*Service+
4) REGEX: 정규 표현식
  ex) org\.example\.Default.*
5) CUSTOM: TypeFilter 이라는 인터페이스를 구현해서 처리
  ex) org.example.MyTypeFilter
* 참고! @Component 면 충분하기 때문에, includeFilters은 거의 사용 안함, excludeFilters 는 여러가지 이유로 간혹 사용할 때가 있지만 많지는 않다.

[중복 등록과 충돌]
1.) 자동 빈 등록 vs 자동 빈 등록
` 컴포넌트 스캔에 의해 자동으로 스프링 빈이 등록되는데, 그 이름이 같은 경우 스프링은 오류를 발생시킨다.
  - ConflictingBeanDefinitionException 예외 발생
2) 수동 빈 등록 vs 자동 빈 등록
` 수동 빈 등록이 우선권을 가진다.
* 최근 스프링 부트에서는 수동 빈 등록과 자동 빈 등록이 충돌나면 오류가 발생하도록 기본 값을 바꾸었다.

[다양한 의존관계 주입 방법]
1) 생성자 주입
 - 생성자 호출시점에 딱 1번만 호출되는 것이 보장된다.
 - 불변, 필수 의존관계에 사용
 - 생성자가 딱 1개만 있으면 @Autowired를 생략해도 자동 주입 된다★
2) 수정자 주입(setter 주입)
 - setter라 불리는 필드의 값을 변경하는 수정자 메서드를 통해서 의존관계를 주입하는 방법
 - 선택, 변경 가능성이 있는 의존관계에 사용
 - 자바빈 프로퍼티 규약의 수정자 메서드 방식을 사용하는 방법이다.
 - @Autowired 의 기본 동작은 주입할 대상이 없으면 오류가 발생한다. 주입할 대상이 없어도      동작하게 하려면 @Autowired(required = false) 로 지정하면 된다.
3) 필드 주입
 - 이름 그대로 필드에 바로 주입하는 방법
 - 외부에서 변경이 불가능해서 테스트 하기 힘들다는 치명적인 단점이 있다.
 - 사용하지 말자!
4) 일반 메서드 주입
 - 일반 메서드를 통해서 주입 받을 수 있다.
 - 한번에 여러 필드를 주입 받을 수 있다.
 - 일반적으로 잘 사용하지 않는다.

[옵션 처리]
` @Autowired(required=false) : 자동 주입할 대상이 없으면 수정자 메서드 자체가 호출 안됨
` org.springframework.lang.@Nullable : 자동 주입할 대상이 없으면 null이 입력된다.
` Optional<> : 자동 주입할 대상이 없으면 Optional.empty 가 입력된다.

[생성자 주입을 선택해라]
` 불변과 누락 방지
 - 생성사 주입을 사용하면 주입 데이터를 누락했을 때, 컴파일 오류가 발생! 필수 주입값 알려줌
 - final키워드 사용가능(나머지 3가지 방법은 생성자 이후에 호출되므로 사용불가)
 - 항상 생성자 주입을 선택! 가끔 옵션이 필요하면 수정자 주입을 선택(필드 주입을 사용X)

[롬복과 최신 트렌드]
` file-settings-plugins 에서 lombok 설치 -> file-settings-annotation processors에서 enabale annotation processing 활성화(gradle에 라이브러리 코드 추가 후 사용 가능)
` 자주쓰고 유용한 기능
 - @Getter/@Setter기능
 - @RequiredArgsConstructor으로 생성자 주입 

[조회 빈이 2개 이상 - 문제]
` 해결방법
 1) @Autowired 필드명: 타입매칭 -> 결과가 2개 이상일 때, 필드명 파라미터명으로 빈이름 매칭
 2) @Qualifier: @Qualifier끼리 매칭, 빈이름 매칭, NoSuchBeanDefinitionException예외 발생
 3) @Primary★: 우선순위를 정하는 방법, 
 - @Primary 는 기본값 처럼 동작하는 것이고, @Qualifier 는 매우 상세하게 동작
 - 자동보다는 수동이, 넒은 범위의 선택권 보다는 좁은 범위의 선택권이 우선순위가 높다 => @Qualifier 가 우선권이 높다.
* ctrl+alt+b : 구현체 보여줌

8. 빈 생명주기 콜백
` 데이터베이스 커넥션 풀이나, 네트워크 소켓처럼 애플리케이션 시작 시점에 필요한 연결을 미리 해두고, 애플리케이션 종료 시점에 연결을 모두 종료하는 작업을 진행하려면, 객체의 초기화와 종료 작업이 필요
` 스프링 빈의 이벤트 라이프사이클
 - 스프링 컨테이너 생성 -> 스프링 빈 생성 의존관계 주입 -> 초기화 콜백 -> 사용 -> 소멸전 콜백 -> 스프링 종료
` 초기화 콜백: 빈이 생성되고, 빈의 의존관계 주입이 완료된 후 호출
` 소면전 콜백: 빈이 소멸되기 직전에 호출
` 결론: 객체의 생성과 초기화를 분리하자!
  - 유지보수에 용이
  - (초기화 작업이 내부 값들만 약간 변경하는 정도로 단순한 경우에는 생성자에서 한번에 다 처리하는게 나을 수 있음)
` 스프링의 빈 생명주기 콜백 지원 3가지 방법
1) 인터페이스(InitializingBean, DisposableBean)
 - 각각 afterPropertiesSet()과 destroy()메서드로 초기화와 소멸을 지원
 - 스프링 초창기에 나온 방법(지금은 거의 사용하지 않음)
 - 단점
    -해당 코드가 스프링 전용 인터페이스에 의존한다.
    - 초기화, 소멸 메서드의 이름을 변경할 수 없다.
    - 코드를 고칠 수 없는 외부 라이브러리에 적용할 수 없다.
2) 빈 등록 초기화, 소멸 메서드 지정
` 설정 정보에 @Bean(initMethod = "init", destroyMethod = "close") 처럼 초기화, 소멸 메서드를 지정할 수 있다.
` 장점
   - 메서드 이름을 자유롭게 줄 수 있다.
   - 스프링 빈이 스프링 코드에 의존하지 않는다.
   - 코드가 아니라 설정 정보를 사용하기 때문에 코드를 고칠 수 없는 외부 라이브러리에도 초기화, 종료 메서드를 적용할 수 있다.
` 종료 메서드 추론
  - @Bean의 destroyMethod는 기본값이 (inferred)추론 으로 등록되어 있다.
  - 이 기능은 close, shutdown라는 이름의 메서드를 자동으로 호출해주고, 종료메서드를 추론해서 호출해준다.
  - 직접 스프링 빈으로 등록하면 종료 메서드는 따로 적어주지 않아도 잘 동작한다.
  - 추론 기능을 사용하기 싫으면 destroyMethod=""처럼 빈 공백을 지정하면 된다. 
3) 애노테이션 @PostConstruct, @PreDestroy ★3개의 방법 중 이거 사용하면 됨!★
` 최신 스프링에서 가장 권장하는 방법이다.
` 애노테이션 하나만 붙이면 되므로 매우 편리하다.
` 패키지를 잘 보면 javax.annotation.PostConstruct 이다. 스프링에 종속적인 기술이 아니라 JSR-250라는 자바 표준이다. 따라서 스프링이 아닌 다른 컨테이너에서도 동작한다.
` 컴포넌트 스캔과 잘 어울린다.
` 유일한 단점은 외부 라이브러리에는 적용하지 못한다는 것이다. 외부 라이브러리를 초기화, 종료 해야 하면@Bean의 기능을 사용하자

9. 빈 스코프
[빈 스코프란?]
` 스코프는 번역 그대로 빈이 존재할 수 있는 범위를 뜻한다.
` 스프링이 지원하는 스코프의 종류
1) 싱글톤
  - 기본 스코프, 스프링 컨테이너의 시작과 종료까지 유지되는 가장 넓은 범위의 스코프
2) 프로토타입
  -  스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입까지만 관여하고 더는 관리하지 않는매우 짧은 범위의 스코프
3) 웹 관련 스코프
  - request: 웹 요청이 들어오고 나갈때 까지 유지되는 스코프
  - session: 웹 세션이 생성되고 종료될 때 까지 유지되는 스코프
  - application: 웹의 서블릿 컨텍스트와 같은 범위로 유지되는 스코프

[프로토타입 스코프]
` 프로토타입 스코프를 스프링 컨테이너에 조회하면 스프링 컨테이너는 항상 새로운 인스턴스를 생성해서 반환한다.
` 작동 순서
  - 프로토타입 스코프의 빈을 스프링 컨테이너에 요청한다.
  - 스프링 컨테이너는 이 시점에 프로토타입 빈을 생성하고, 필요한 의존관계를 주입한다.
  - 스프링 컨테이너는 생성한 프로토타입 빈을 클라이언트에 반환한다.
  - 이후에 스프링 컨테이너에 같은 요청이 오면 항상 새로운 프로토타입 빈을 생성해서 반환한다.
★ 핵심은 스프링 컨테이너는 프로토타입 빈을 생성하고, 의존관계 주입, 초기화까지만 처리한다는 것이다.
` 프로토타입 빈의 특징
  - 스프링 컨테이너에 요청할 때 마다 새로 생성된다.
  - 스프링 컨테이너는 프로토타입 빈의 생성과 의존관계 주입 그리고 초기화까지만 관여한다.
  - 종료 메서드가 호출되지 않는다.
  - 그래서 프로토타입 빈은 프로토타입 빈을 조회한 클라이언트가 관리해야 한다. 종료 메서드에 대한 호출도 클라이언트가 직접 해야한다.

[싱글톤 빈과 함께 사용시 문제점]
` 스프링 컨테이너에 프로토타입 스코프의 빈을 요청하면 항상 새로운 객체 인스턴스를 생성해서 반환하지만, 싱글톤 빈과 함께 사용할 때는 의도한 대로 잘 동작하지 않으므로 주의 필요
` 싱글톤 빈은 생성 시점에만 의존관계 주입을 받기 때문에, 프로토타입 빈이 새로 생성되기는 하지만, 싱글톤 빈과
함께 계속 유지되는 것이 문제

[싱글톤 빈과 함께 사용시 Provider로 문제 해결]
1) 스프링 컨테이너에 요청
` 가장 간단한 방법으로, 싱글톤 빈이 프로토타입을 사용할 때 마다 스프링 컨테이너에 새로 요청하는 것
` 스프링의 애플리케이션 컨텍스트 전체를 주입받게 되면, 스프링 컨테이너에 종속적인 코드가 되고, 단위 테스트도 어려워진다.
2) ObjectFactory, ObjectProvider
` 지정한 빈을 컨테이너에서 대신 찾아주는 DL 서비스를 제공하는 것이 바로 ObjectProvider 이다
(DL: 의존관계를 외부에서 주입(DI) 받는게 아니라 이렇게 직접 필요한 의존관계를 찾는 것을 Dependency Lookup의존관계 조회라고 한다)
` ObjectFactory: 기능이 단순, 별도의 라이브러리 필요 없음, 스프링에 의존
` ObjectProvider: ObjectFactory 상속, 옵션, 스트림 처리등 편의 기능이 많고, 별도의 라이브러리 필요없음, 스프링에 의존
3) JSR-330 Provider
` javax.inject.Provider 라는 JSR-330 자바 표준을 사용하는 방법
` javax.inject:javax.inject:1 라이브러리를 gradle에 추가해야 한다.
` provider 의 get() 을 호출하면 내부에서는 스프링 컨테이너를 통해 해당 빈을 찾아서 반환한다. (DL)
` 특징
  - get() 메서드 하나로 기능이 매우 단순하다.
  - 별도의 라이브러리가 필요하다.
  - 자바 표준이므로 스프링이 아닌 다른 컨테이너에서도 사용할 수 있다.

[프로토타입 빈 정리]
` 프로토타입 빈을 언제 사용할까? 매번 사용할 때 마다 의존관계 주입이 완료된 새로운 객체가 필요하면 사용하면 된다. 그런데 실무에서 웹 애플리케이션을 개발해보면, 싱글톤 빈으로 대부분의 문제를 해결할 수 있기 때문에 프로토타입 빈을 직접적으로 사용하는 일은 매우 드물다.
` ObjectProvider , JSR330 Provider 등은 프로토타입 뿐만 아니라 DL이 필요한 경우는 언제든지 사용할 수 있다
` 코드를 스프링이 아닌 다른 컨테이너에서도 사용할 수 있어야 한다면 JSR-330 Provider를 사용하겠지만, 특별히 다른 컨테이너를 사용할 일이 없다면 스프링이 제공하는 기능을 사용하자!

[웹 스코프]
` 특징
  - 웹 스코프는 웹 환경에서만 동작한다.
  - 웹 스코프는 프로토타입과 다르게 스프링이 해당 스코프의 종료시점까지 관리. 따라서 종료 메서드가 호출된다.
` 웹 스코프 종류
1) request
  - HTTP 요청 하나가 들어오고 나갈 때 까지 유지되는 스코프, 각각의 HTTP 요청마다 별도의 빈 인스턴스가 생성되고, 관리된다.
  - 동시에 여러 HTTP 요청이 오면 정확히 어떤 요청이 남긴 로그인지 구분하기 어렵다. 이럴때 사용하기 딱 좋은것
  - 오류 발생, 실제 고객의 요청이 와야 생성할 수 있음(Provider와 프록시로 해결)
2) session: HTTP Session과 동일한 생명주기를 가지는 스코프
3) application: 서블릿 컨텍스트( ServletContext )와 동일한 생명주기를 가지는 스코프
4) websocket: 웹 소켓과 동일한 생명주기를 가지는 스코프

[스코프와 Provider]
` ObjectProvider 덕분에 ObjectProvider.getObject() 를 호출하는 시점까지 request scope 빈의 생성을 지연할 수 있다.
` ObjectProvider.getObject() 를 호출하시는 시점에는 HTTP 요청이 진행중이므로 request scope 빈의 생성이 정상 처리된다.

[스코프와 프록시]
` proxyMode = ScopedProxyMode.TARGET_CLASS 를 추가
  - 적용 대상이 인터페이스가 아닌 클래스면 TARGET_CLASS 를 선택
  - 적용 대상이 인터페이스면 INTERFACES 를 선택
` MyLogger의 가짜 프록시 클래스를 만들어두고 HTTP request와 상관 없이 가짜 프록시 클래스를 다른 빈에 미리 주입해 둘 수 있다.
` 특징
  - 프록시 객체 덕분에 클라이언트는 마치 싱글톤 빈을 사용하듯이 편리하게 request scope를 사용할 수 있다.
  - Provider를 사용하든, 프록시를 사용하든 핵심 아이디어는 진짜 객체 조회를 꼭 필요한 시점까지 지연처리 한다는 점이다.
  - 단지 애노테이션 설정 변경만으로 원본 객체를 프록시 객체로 대체할 수 있다. 이것이 바로 다형성과 DI 컨테이너가 가진 큰 강점이다.
  - 꼭 웹 스코프가 아니어도 프록시는 사용할 수 있다.
